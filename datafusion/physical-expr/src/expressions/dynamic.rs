// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

use std::{any::Any, hash::Hash, sync::Arc};

use datafusion_expr::ColumnarValue;
use datafusion_physical_expr_common::physical_expr::PhysicalExpr;
use datafusion_common::error::Result;

/// A source for dynamically generated PhysicalExprs.
/// Operators may want to dynamically generate a PhysicalExpr lazily at runtime.
/// For example, a TopK operator can push down it's current state into a join operator
/// to dynamically filter rows that would not be in the TopK anyway as the join takes place.
pub trait DynamicPhysicalExprSource: Send + Sync + std::fmt::Debug + 'static {
    /// Returns a PhysicalExpr that may be dynamically generated by the implementer.
    fn current_expr(&self) -> Result<Arc<dyn PhysicalExpr>>;
}

#[derive(Debug)]
pub struct DynamicPhysicalExpr {
    current: Arc<dyn PhysicalExpr>,
    inner: Arc<dyn DynamicPhysicalExprSource>,
}

impl std::fmt::Display for DynamicPhysicalExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Ok(expr) = self.inner.current_expr() {
            write!(f, "DynamicPhysicalExpr({})", expr)
        } else {
            write!(f, "DynamicPhysicalExpr(?)")
        }
    }
}

impl DynamicPhysicalExpr {
    pub fn new(inner: Arc<dyn DynamicPhysicalExprSource>) -> Result<Self> {
        let current = inner.current_expr()?;
        Ok(Self { current, inner })
    }

    pub fn current(&self) -> Arc<dyn PhysicalExpr> {
        self.inner.current_expr().unwrap_or_else(|_| self.current.clone())
    }
}


// Manually derive PartialEq and Hash to work around https://github.com/rust-lang/rust/issues/78808
impl PartialEq for DynamicPhysicalExpr {
    fn eq(&self, other: &Self) -> bool {
        self.current().eq(&other.current())
    }
}

impl Eq for DynamicPhysicalExpr {}

impl Hash for DynamicPhysicalExpr {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.current().hash(state)
    }
}


impl PhysicalExpr for DynamicPhysicalExpr {
    /// Return a reference to Any that can be used for downcasting
    fn as_any(&self) -> &dyn Any {
        self
    }

    fn children(&self) -> Vec<&Arc<dyn PhysicalExpr>> {
        // Can't get children, returning an &Arc would require returning a reference to a temporary value
        vec![]
    }

    fn with_new_children(
        self: Arc<Self>,
        _children: Vec<Arc<dyn PhysicalExpr>>,
    ) -> Result<Arc<dyn PhysicalExpr>> {
        // Do we need to do something here?
        Ok(self)
    }

    fn data_type(&self, input_schema: &arrow::datatypes::Schema) -> Result<arrow::datatypes::DataType> {
        self.inner.current_expr()?.data_type(input_schema)
    }

    fn nullable(&self, input_schema: &arrow::datatypes::Schema) -> Result<bool> {
        self.inner.current_expr()?.nullable(input_schema)
    }

    fn evaluate(&self, batch: &arrow::record_batch::RecordBatch) -> Result<ColumnarValue> {
        self.inner.current_expr()?.evaluate(batch)
    }

    fn fmt_sql(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Ok(expr) = self.inner.current_expr() {
            expr.fmt_sql(f)
        } else {
            write!(f, "DynamicPhysicalExpr")
        }
    }
}
